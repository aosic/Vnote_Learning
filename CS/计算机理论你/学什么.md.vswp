vnote_backup_file_826537664 E:/my_Gitbook/CS/计算机理论你/学什么.md
作者：朱俸民  
链接：https://www.zhihu.com/question/19628851/answer/103841898  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  
  

**正统篇**  
1\. 编程入门（如C、python 等）  
2\. 数学基础（一阶逻辑系统、集合论、图论、线性代数、微积分、概率论）  
3\. 数据结构与算法  
4\. 软件理论入门（形式语言、自动机）  
5\. 体系结构（数字电路、CPU设计、操作系统、编译器、网络协议）

**理论篇**  
1\. 逻辑（一阶逻辑、时序逻辑）  
2\. 代数（线性代数、抽象代数）  
3\. 算法（设计、复杂度分析、证明）  
4\. 软件理论（形式语言、自动机、可计算性理论）  
5\. 程序语言理论（Lambda 演算、类型系统、证明论等）

**系统篇**  
1\. C 语言是汇编的语法糖  
2\. 造台计算机（CPU）  
3\. 写个工具链（编译器后端工具链构建）  
4\. 操作系统（原理和实现）  
5\. 计算机网络（原理和协议栈实现）

**机器学习篇**  
1\. python入门  
2\. 概率论、统计  
3\. 机器学习导论  
4\. 人工神经网络  
5\. 调参实践

**前端篇**  
1\. 前端审美基础（HTML5、CSS）  
2\. javascript入门  
3\. 多范式编程（面向对象、函数式、异步）  
4\. 工程管理导论（如何版本控制、如何炒别人网站的样式、如何忽悠项目经理）  
5\. 前端项目实践（如何使用框架）

======= 更新 2016-06-06 =======  
**前端进阶****篇**  
1\. javascript进阶  
2\. 数据可视化  
3\. UI 交互理论  
4\. 函数式编程  
5\. FRP (Functional Reactive Programming)

**后端篇**  
1\. 编程入门（python/PHP/etc.）  
2\. 网站开发导论（HTTP、Web 3.0、MVC 架构、流行的后端框架）  
3\. 数据库架构设计  
4\. OAuth 与 Restful API 的哲学和设计  
5\. Saas 项目实战

**后端进阶篇**  
1\. 并行程序设计  
2\. 密码学  
3\. 计算机网络  
4\. 函数式编程（Scala）  
5\. Reactive Programming

**软件工程（现实）篇**  
（假设已经有编程基础）

1\. 需求分析（如何与用户撕*）  
2\. UML建模（如何增加文档页数）  
3\. 敏捷开发（如何压榨程序员、为什么用户需求又变了）  
4\. 测试（如何用完项目经费）  
5\. 部署与运维（为什么客户老是反映系统有 bug）

**软件工程（理想）篇**  
（假设已经有编程基础）

1\. 软件开发方法导论（瀑布式开发、敏捷开发、模型驱动开发）  
2\. Web 和移动端应用开发实战  
3\. 软件系统形式化建模（Petri 网、时间自动机、进程代数等）  
4\. 测试与验证（单元测试、运行时验证、模型检测）  
5\. 模型驱动开发实战

**形式验证篇**  
（假设已修：微积分、概率论、随机过程、离散数学、代数）  
1\. 软件理论基础（形式语言、自动机、可计算性理论）  
2\. 程序构造与解释  
3\. 模型检测与软件验证（时序逻辑、模型检测算法、静态分析、谓词抽象）  
4\. 定理证明（Coq、Isabelle）  
5\. 形式化方法前沿专题（概率模型检测、程序综合、运行时验证）

===== 回答几个评论区的问题 =====  
1\. 英语放进去？  
假设学术英语作为已修课程。

2\. 软件开发和数学的联系？  
引用某老师课上的话，“如果你只是想做一个‘码农’，即项目的需求已经明确了，框架也有架构师搭好了，甚至于接口都已经定义清楚了，剩下你做的只是编码去实现这个接口，那么你确实不需要数学。但是如果你想做比这个高一点点层次的东西，就会发现数学是很用的。”

也许一部分工业界的人由于平时对理论关注较少，更多的是考虑工程上的实践问题，所以会有一种数学没有用的感觉。但是，从软件理论的角度来看，数学是其中最核心的基础。研究软件理论的人，往往先对软件进行建模，然后透过模型来研究其性质，比如一些用户需求是否被满足。这些工作对相关数学理论，如代数、概率论、随机过程等的依赖是相当高的。即使是工业界做开发，当所开发的系统需要用到形式化模型时，就会不可避免地用到数学，如控制系统（自动机）、通信系统（进程代数、通信自动机等）、传输系统（Petri 网）、概率系统（Markov 链）。掌握更多的理论工具，对于解决实际问题是有很大帮助的。很多时候，推动工业发展的不是经验，而是理论。


























如需要详细解释某部分排序，请回复）

1\. **集合论与数理逻辑**  
2\. **可计算性理论**  
3\. **计算复杂性**  
4\. 算法博弈论  
5\. 数据结构与算法

以上1>2>3>4≈5  
如果不限制5门课，继续排的话，那么

6\. 数学分析  
7\. 线性代数  
8\. 抽象代数  
9\. 概率论  
10\. 计算机系统（组成，编译，操作系统）

这里5>6>7≈8>9≈10

继续排，

11\. 分布式系统  
12\. 计算机网络  
13\. 图论与组合  
14\. 机器学习  
15\. 程序设计  
16\. 数据库  
17\. 电路电子学

10>11≈12>13≈14≈15>16>17

最后，如果要考虑英语的话，英语≈4、5

  
  
作者：爱丽丝欣  
链接：https://www.zhihu.com/question/19628851/answer/31790810  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


























































































 p, li { white-space: pre-wrap; } 

作者：Climber.pI

链接：https://www.zhihu.com/question/27306122/answer/215562978

来源：知乎

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

  

先抖个机灵. Manuel Blum 大概是自己门生拿 Turing Award 拿得最多的人. 他的主页上有段类似\[“给研究生的建议”\](https://link.zhihu.com/?target=https%3A//www.cs.cmu.edu/~mblum/research/pdf/grad.html)之类的文字, 其中有段:

  

\- 你是个计算机科学家, 你知道有限状态自动机 (Finite Automata) 能干什么, 你也知道图灵机 (Turing Machine) 能干什么. 比如说, FA 只能加不能乘, TM 能计算所有可计算函数. TM 当然有着比 FA 强得多的计算能力. *而他们直接唯一的不同是, 不像 FA, TM 有纸和铅笔*. 仔细想想. \\-\\- 这告诉你了写下来 (writing) 的力量. 要是不写, 你就退化成了 FA. 写下来的话, 你就成了拥有非凡能力 (extraordinary power) 的 TM.

  

于是呢, 你需要学习计算理论来理解有限状态自动机和图灵机分别是什么东西......然后进一步提高自己的学习能力(误

  

  

正经回答的话, 计算理论作为一门低年级本科生课, 存在的意义不外乎初步地介绍理论计算机科学. 尽管这样的介绍对于大多数人来说, 也许意义仅限于欣赏美妙的结果或是智力游戏而已. 虽然事实上并不如此.

  

理论计算机中有个范式: **首先对问题 X 给出形式化的严格定义, 然后证明哪些事情对于 X 可行, 哪些事情对于 X 不可行.** 这样的问题 X 可能是计算(对应于可计算性), 可能是满足一定资源限制(如时间或空间)下的计算(对应于计算复杂性), 也可能是没法学到(对应于密码学).

  

回到传统风格的计算理论教学中, 第一部分自动机理论和第二部分图灵机, 回答的是什么是不可计算的; 最后一部分会介绍一些计算复杂性类 (诸如 P 和 NP, 给几个 NP-complete 的例子), 回答的是什么是能有效计算的. 在这方面做到极致的教材应该说是 Michael Sipser 的 \*Introduction to Theory of Computation\*. 当然对于国内绝大多数高校而言, 能把这三部分说清楚已经是难能可贵, 至少我本科(华东五校之一)上的那门按这个标准来看是不合格的; 甚至后来, 上课的这位老师还在一些场合表达过"*这个领域很多年没更新了*"这种极其不负责任的话. 当然国内也有好的例子, 比如复旦的陈翌佳老师的这门 \[Theory of Computation\](https://link.zhihu.com/?target=http%3A//basics.sjtu.edu.cn/~chen/teaching/TOC/).

  

  

这些东西的用途和与其他领域的联系呢? 随手写一些吧:

  

\- 自动机理论和编译原理, 当然还有 Chomsky 谱系之类的东西, 虽然从教学的角度上看更像是历史包袱;

\- 楼上有人提到的, Lambda calculus 和程序语言理论; Neil D. Joss 有本 Computability and Complexity: From a Programming Perspective 就是从这个角度展开的.

\- 随机算法和概率方法. 如果介绍一些基本的复杂性类, 如 BPP 或 MA 的话, 那么一定绕不开 Chernoff bound, 再进一步就到了随机算法, 和机器学习不无联系;

\- 基于计算复杂性的现代密码学, 诸如类似零知识证明的交互式证明系统 (interactive proof), 各类 protocol 的安全性证明;

\- 复杂性理论和量子计算, 甚至更一般的理论物理的联系.

  

当然, 大致说清楚上面这些东西, 一门计算理论或是计算复杂性理论显然是远远不够的......至少还得开门随机算法, 再来门密码学基础, 外加门程序语言理论基础, 最后再来个量子信息的入门课. 恕我直言, 国内能给本科生开齐这些的学校, 说是凤毛麟角现在恐怕都是夸张.

  

  

可即使是一样的东西, 随着整个圈子对其了解的日渐深入, 看待它的观点也会发生变化. 比如说 NP, 非确定性多项式时间内可以求解的问题. "非确定性多项式时间"这话, 早期的处理方式是用非确定性图灵机, 也就是说考虑树状的历史路径和树叶所在的深度来定义. 更现代的处理方式是用多项式时间可验证解的问题来定义 NP, 为什么一定要用交互式证明系统来定义呢?

  

从历史地位来说, 2012年的 Turing award 得主, Silvio Micali 和 Shafi Goldwasser 的工作就是 interactive proof 及其在密码学中的应用(零知识证明); 而交互式证明系统相关的工作, 分别在 1993 年和 2001 年两度获得 Godel Prize (论文奖), 后者是 PCP 定理与不可近似性的关系. 而现在人们同样在尝试从某些交互式系统中出发, 设计验证量子设备的 protocol; 我丝毫不怀疑日后还会有相关工作拿到类似奖项.

  

从技术上来说, 考虑有证明者 P 和验证者 V 的交互式证明系统, 我们对证明者 P 在计算上的能力不加限制, 但限制验证者 V 的能力. 我们可以对这类系统的定义做一些修改:

  

\- 如果验证者 V 完全没有随机性的话, 那么这样的多轮交互所刻画的复杂性类和 NP 相同, 即只有从证明者到验证者的一轮交互 (你给我证明, 我看看对不对; 对了一定接受, 不对一定没戏).

\- 而如果给验证者增加随机性的话, 就会导出更加奇妙的结果: 我们可以把证明写成某种特殊形式, 每条片段都只有常数 !\[O(1)\](https://www.zhihu.com/equation?tex=O%281%29) 长度, 这样的片段可以用 !\[\\log(n)\](https://www.zhihu.com/equation?tex=%5Clog%28n%29) 的字符串编码索引. 如果验证者接受所有正确证明, 但是有超过一半的几率拒绝错误证明的话, 称为概率可检查证明(Probabilistic Checkable Proof)系统. 可以证明 !\[\\mathrm{NP}=\\mathrm{PCP\[log(n),1\]}\](https://www.zhihu.com/equation?tex=%5Cmathrm%7BNP%7D%3D%5Cmathrm%7BPCP%5Blog%28n%29%2C1%5D%7D) . 也就是说**如果我们把证明片段洒向空中, 如同漫天飞舞的雪花的话, 我们只需要几片就有超过一半的几率判断证明是否正确**, 进而导出不可近似性.

\- 如果给验证者增加量子性的话, 即验证者是一台量子计算机 ( !\[\\mathrm{BQP}\](https://www.zhihu.com/equation?tex=%5Cmathrm%7BBQP%7D) ), 我们就得到了所谓的量子 NP 类 ( !\[\\mathrm{QMA}\](https://www.zhihu.com/equation?tex=%5Cmathrm%7BQMA%7D) ), 进而得以刻画某些即使有量子计算机仍然难以有效求解的问题.

\- 如果在给验证者增加随机性(即验证者计算能力为 !\[\\mathrm{BPP}\](https://www.zhihu.com/equation?tex=%5Cmathrm%7BBPP%7D) )的同时, 允许多轮交互的话, 那么这样的系统足够验证任何解在多项式空间内的问题, 即 !\[\\mathrm{IP=PSPACE}\](https://www.zhihu.com/equation?tex=%5Cmathrm%7BIP%3DPSPACE%7D); 但即使我们给验证者增加量子性, 并允许多轮交互, 并不能得到计算能力更强的系统, 即 !\[\\mathrm{QIP}=\\mathrm{IP}\](https://www.zhihu.com/equation?tex=%5Cmathrm%7BQIP%7D%3D%5Cmathrm%7BIP%7D) .

  

因而, 即使仅仅是对已有概念在教学上的做更好的处理, 也能够帮助我们更好地理解新的结果.

  

  

回到教学本身. 其实早就有了些比 Sipser 那本教材更激进的尝试, 比如 Scott Aaronson 几年前在 MIT 开的 \[http://stellar.mit.edu/S/course/6/sp16/6.045/materials.html\](https://link.zhihu.com/?target=http%3A//stellar.mit.edu/S/course/6/sp16/6.045/materials.html). 前些日子看到了 Boaz Barak 的博文(\[Rethinking the “Intro Theory” course\](https://link.zhihu.com/?target=https%3A//windowsontheory.org/2017/07/27/rethinking-the-intro-theory-course/)), 想来尚未完稿的 \[Introduction to Theoretical Computer Science\](https://link.zhihu.com/?target=http%3A//www.introtcs.org/public/index.html) 也是本令人期待的教材.

  

简而言之, 即使对于相关方向从业人员(如机器学习理论或密码学), 广义的计算理论这门课仍然在技术上能提供直接的帮助; 对于更多的人, 也可以介绍一些全新的理解事物的方式, 这也是理论研究的美妙之处吧.
















