https://www.csdn.net/article/2012-03-09/312909
编程语言






















# 教材
# 程序设计语言理论（PLT）领域里有哪些经典的教材？
https://www.zhihu.com/question/31883401

https://www.zhihu.com/question/31883401/answer/123323587

[阿莱克西斯](https://www.zhihu.com/people/ming-zi-zong-shi-hen-nan-qi)

、

[Oling Cat](https://www.zhihu.com/people/olingcat)
 神课 https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html
、

[lfkdsk](https://www.zhihu.com/people/lfkdsk)

、

[圆角骑士魔理沙](https://www.zhihu.com/people/marisa.moe)

等 133 人赞同了该回答

谢邀, 其实我是不喜欢这种列举书单的问题, 你为什么不问问神奇海螺呢?  
但是居然有三个人邀请, 那就答一下好了.

在我的视野里, *综合类*PL的教材一般分两种, 一种是整本书里会分不同的主题, PL里的一些基本元素(语法, 语义), 数据抽象模型, 并发/并行模型之类的. 还有一种就是写解释器, 从头到尾都在写解释qi之类的, 当然还有不少"异类", 专注写某个主题的也有很多.

综合类比较新的大概Sebesta的[Concepts of Programming Languages (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/10581203/), 我看过第八版的中文版前面几章觉得比较枯燥无味, 现在已经出到第十版了, 还有一本比较新的是Scott的[Programming Language Pragmatics, Third Edition (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3743526/) 我看的是裘宗燕翻译的第二版, 现在已经出到第三版, 当时读这本书的感觉很舒服, 对PL的很多东西有一个概览, 而且牵涉了一点编译器,虚拟机运行时,体系结构的东西, 当时还没接触编译原理, 这些部分很有意思. 其他的还有[Concepts in Programming Languages (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2587705/) 没看过

然后解释器流. 先不说很纯的那种, SICP跟CTM像是中间派, 还有本也是MIT出的[Design Concepts in Programming Languages (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3235958/) 没看过, 这类都是用一种语言讲到底的, 而不是之前那些各种语言都拿来说一下. 纯解释器流最出名的估计是EoPL [Essential of Programming Languages, 3rd Edition (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/3136252/), 另外有本不是很出名的LiSP [Lisp in Small Pieces (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1456904/) , 还有近年Racket那边的人写的[Programming Languages (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/11628134/) 全书免费公开, 还有课程视频, 真业界良心. 还有本比较旧的Programming Languages: An Interpreter-Based Approach 在被改写成 [Programming Languages: Build, Prove, and Compare](https://link.zhihu.com/?target=http%3A//www.cs.tufts.edu/~nr/build-prove-compare/)

类型系统走不掉TaPL [Types and Programming Languages](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1761910/)还有 ATaPL, Harper的[Practical Foundations for Programming Languages (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/11632210/)

**至于路线什么的, 挑门FP语言写各种解释器把 [Lambda cube](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lambda_cube) 每个角都过一遍就好.**

  

列文献我也有一车啊, 那又怎么样  
[Undergraduate Courses About Programming Languages](https://link.zhihu.com/?target=http%3A//www.eecs.ucf.edu/~leavens/teaching-prog-lang/Undergraduate.html)  
[Graduate Courses About Programming Languages](https://link.zhihu.com/?target=http%3A//www.eecs.ucf.edu/~leavens/teaching-prog-lang/Graduate.html)  
[wiki/index.md at master · soimort/wiki · GitHub](https://link.zhihu.com/?target=https%3A//github.com/soimort/wiki/blob/master/plt/index.md)  
[Readings for CS 152](https://link.zhihu.com/?target=http%3A//www.cs.tufts.edu/~nr/cs152/readings/indexbody.html)  
[编程语言相关的好书 \- Continuation - 知乎专栏](http://zhuanlan.zhihu.com/forallplt/19917853)  
[ProgrammingLanguageTheoryTextsOnline < Techno < UUCS](https://link.zhihu.com/?target=http%3A//www.cs.uu.nl/wiki/Techno/ProgrammingLanguageTheoryTextsOnline)  
[文献汇编](https://link.zhihu.com/?target=http%3A//www.math.pku.edu.cn/teachers/qiuzy/plan/lits/)

伸手党退散, 就是这样





https://www.zhihu.com/question/315021281/answer/623876346 语言大一统
# 程序语言理论的学习对于程序员教育的作用
https://www.cnblogs.com/zhanglong8681/p/4814102.html
https://www.zhihu.com/question/27146059

最好的做法就是学习语义，这方面的书籍包括但不限于：

《Essentials of Programming Languages》

《Programming Languages Application and Interpretation》

《Design Concepts in Programming Languages》

等等

之后你会用各种语义的组合的眼光来看现有的各种语言

  
  
作者：baozii  
链接：https://www.zhihu.com/question/315021281/answer/617594687  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


作者：游客账户0x0  
链接：https://www.zhihu.com/question/315021281/answer/623876346  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  
  

一般来说，big step semantic足矣。但是只有big step semantic什么性质都导不出来，只是告诉你这个语言是这么运行的罢了。big step semantic也不能很好地告诉你某个语言的特色是什么。

对于有类型的语言，事情就方便多了。参见the definition of standarf ML。这次，除了描述这个语言如何工作，还能证明性质。

最后是denotational semantic。这是个神奇的东西。拿一般的域论语义来说，denotational semantic可以告诉你这个语言支持哪些feature。而且像和continuation，state有关系的那堆东西用denotational semantic会很舒服。直接把continuation和store扔进指称论域就行了。eff的paper里给的就是denotational semantic，因为eff的effect system需要continuation上的操作和store。

多说一句denotational semantic，这玩意还有个bonus大招，就是你把指称论域选成meta language的类型和项，那么你就得到了一个object language的解释器。更有趣的是，big step semantic也能对着写出解释器，但是denotational semantic对应出来是一个HOAS的解释器，而big step semantic对应出来是标准的top down解释器。

  

————————————

用个lambda calculus的解释器来说明一下HOAS是什么。

type expr = Var of string

| Lam of (string * expr)

| App of (expr * expr)

标准的top down版本（big step semantic）

let rec eval context expr =

match expr with

| Var var -> findVar var context

| Lam _ -> expr

| App(e1, e2) ->

match eval context e1 with

| Lam(arg, body) -> eval (addVar arg (eval context e2) context) body

| _ -> error “not a function”

HOAS版本

let var id context = findVar id context

let lam arg body value context = body（addVar arg value context）

let app e1 e2 context = （e1 context）（e2 context）

let eval expr = expr emptyContext

可以看到object language的函数在这里全部变成了meta language的函数。其实HOAS的本质就是用meta language的A功能实现object language的A功能，最常见的就是函数。HOAS也可以用ast来表示code，但这里用的tagless final style演示起来更有特点更清爽（

  
https://zhuanlan.zhihu.com/c_156166721 # 作为工具的语言

探讨控制机器的文本最好应该是什么样
—————————————

再次更新。其实big step和small step semantic合称operational semantic。字面意思，用于描述如何“操作”语言。至于big step，small step什么区别，其它的axiom semantic之类，毕竟不是适合在知乎学的东西，好的科普书和paper是很多的。如果要看语义和类型的联系，强烈推荐TAPL





编程语言不同，它没有标准答案，所有人都按自己的口味，谁也不服谁。

Java知道吧。JVM刚出来的时候，人们高呼平台差距被统一了，大家再也不用为不同的平台写编译器，直接编译到Java Byte Code就能Write Once Run Everywhere.

然后，微软说，你这JVM设计的不好，我搞个.NET出来。

谷歌说，你们干嘛不用个高级语言做中间代码，你看我基于V8引擎搞个Node，然后你们写JS就好了。

苹果说，你们这些JIT都是罪恶的，AOT才是王道。用我的LLVM照样能统一平台。

你看，本以为JVM能统一平台，结果，蹦出来一大堆同类的能统一平台的产品，结果导致这些“大一统”的产品之间变得不能统一了。

然后大家为了统一本意是统一平台的JVM、.NET、Node、LLVM，又搞出了能编译到各个平台的编程语言。比如Scala，最早可以编译到JVM和.NET，现在Scala.js和Scala Native又能编译到后两个平台。

然后你以为Scala就大一统了？不，历史又一次重复上演，Kotlin出来了，编译到JVM、JS，也能AOT。

F#可以编译到.NET和JS，并且整个.NET支持AOT.

。。。。

  
  
作者：李东恒  
链接：https://www.zhihu.com/question/315021281/answer/617063761  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。











































































